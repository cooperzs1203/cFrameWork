package cLog

import (
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"
	"time"
)

const (
	_FILE_PATH_ = "./log"
	_FILE_SUFFIX_ = "txt"
	_FOMAT_YEAR_MONTH_DAY_ = "20060102"
	_GB_ = 1024*_MB_
	_MB_ = 1024*_KB_
	_KB_ = 1024*1
)

func init() {
	err := createLogDirIfNotExists() // 检查并创建 ./log 文件夹
	if err != nil {
		LogSystem("检查并创建 ./log 文件夹错误 : %s" , err.Error())
		panic(err)
	}
	LogSystem("检查并创建 ./log 文件夹成功")
}

func createLogDirIfNotExists() error {
	LogSystem("./log 文件夹检查")
	fileInfo , err := os.Stat(_FILE_PATH_)
	if err != nil {
		if !os.IsExist(err) {
			LogSystem("./log 文件夹不存在，创建中")
			return os.Mkdir(_FILE_PATH_ , os.ModePerm)
		} else {
			LogSystem("检查 ./log 信息发生错误")
			return err
		}
	}

	if !fileInfo.IsDir() {
		LogSystem("./log 文件夹不存在，创建中")
		return os.Mkdir(_FILE_PATH_ , os.ModePerm)
	}

	LogSystem("./log 文件已存在")

	return nil
}

func checkFileOverSize(maxSize int64 , filePath string) bool {
	log.Println(filePath)
	fileInfo , err := os.Stat(filePath)
	if err != nil {
		LogSystem("checkFileOverSize error : %s" , err.Error())
		return true
	}

	LogSystem("%s 占用空间 %d" , filePath , fileInfo.Size())
	if fileInfo.Size() >= maxSize {
		return true
	}

	return false
}

func LoadcLog() error {
	err := systemLog.load()
	if err != nil {
		return err
	}
	err = debugLog.load()
	if err != nil {
		return err
	}

	return nil
}











var debugLog = &cLog{
	logLevel: logLevel[Debug],
	logFilePath: _FILE_PATH_,
	todayFileCount: 1,
	msgChan: make(chan string, 5000),
}

var systemLog = &cLog{
	logLevel: logLevel[System],
	logFilePath: _FILE_PATH_,
	todayFileCount: 1,
	msgChan: make(chan string, 5000),
}

type cLog struct {
	logLevel string

	logger *log.Logger

	file *os.File
	logFilePath string
	logFileName string
	todayFileCount int

	msgChan chan string
}

func (clog *cLog) load() error {
	err := clog.buildCurrentFileName() // 构建今日日志文件前缀
	if err != nil {
		return err
	}

	// load 初创句柄
	err = clog.createAndUseLogFile()

	clog.monitorPrint()
	clog.monitorTodayTimeOut()
	clog.monitorFileSize()

	return nil
}

func (clog *cLog) buildCurrentFileName() error {
	clog.logFileName = time.Now().Format(_FOMAT_YEAR_MONTH_DAY_)

	// strings.TrimRight(clog.getCurrentLogFilePath() , fmt.Sprintf("_%d.%s" , clog.todayFileCount , _FILE_SUFFIX_)) trimleft的文件头

	files := make([]string , 0)
	err := filepath.Walk(_FILE_PATH_ , func(path string, info os.FileInfo, err error) error {
		if !info.IsDir() && strings.HasPrefix(info.Name() , strings.TrimRight(clog.getCurrentLogFilePath() , fmt.Sprintf("_%d.%s" , clog.todayFileCount , _FILE_SUFFIX_))) {
			files = append(files , info.Name())
		}
		return nil
	})
	if err != nil {
		return err
	}

	log.Println(files)

	clog.todayFileCount = len(files)
	// todo:当len(files)==0时，永远只会探求这一个
	if over := checkFileOverSize(20*_MB_ , clog.getCurrentLogFilePath()); over {
		clog.todayFileCount = len(files) + 1
	}

	return nil
}

func (clog *cLog) createAndUseLogFile() error {
	file , err := os.OpenFile(clog.getCurrentLogFilePath() , os.O_CREATE|os.O_APPEND|os.O_WRONLY , 0755)
	if err != nil {
		return err
	}

	if clog.file != nil {
		_ = clog.file.Close()
	}

	clog.file = file
	clog.setOutPut(io.Writer(clog.file))
	return nil
}

func (clog *cLog) getCurrentLogFilePath() string {
	fileName := fmt.Sprintf("%s_%s_%d.%s" , clog.logLevel , clog.logFileName , clog.todayFileCount , _FILE_SUFFIX_)
	return filepath.Join(clog.logFilePath , fileName)
}

func (clog *cLog) setOutPut(w io.Writer) {
	if clog.logger == nil {
		clog.logger = log.New(w , "" , 0)
	} else {
		clog.logger.SetOutput(w)
	}
}

func (clog *cLog) monitorPrint() {
	LogSystem("%s - 开启消息监听打印" , clog.logLevel)
	go func() {
		for {
			msg := <- clog.msgChan
			clog.logger.Println(msg)
		}
	}()
}

func (clog *cLog) monitorTodayTimeOut() {
	LogSystem("%s - 开启换天倒计时" , clog.logLevel)
	go func() {
		for {
			nowTime := time.Now()
			todayEndTime := nowTime.Add(time.Duration(24) * time.Hour).Format("2006-01-02") + " 00:00:00"
			loc , _ := time.LoadLocation("Local")
			te , err := time.ParseInLocation("2006-01-02 15:04:05" , todayEndTime , loc)
			if err != nil {
				log.Println(err)
				continue
			}
			countSec := te.Sub(nowTime).Seconds()

			<- time.After(time.Second * time.Duration(countSec))
			LogSystem("%s - 日志天更新" , clog.logLevel)

			currentFilePrefix := te.Format(_FOMAT_YEAR_MONTH_DAY_) // 构建新一天日志文件前缀
			clog.logFileName = currentFilePrefix
			clog.todayFileCount = 1

			err = clog.createAndUseLogFile()
			if err != nil {
				panic(err)
			}
		}
	}()
}

func (clog *cLog) monitorFileSize() {
	LogSystem("%s - 开启文件占用空间监控" , clog.logLevel)
	go func() {
		for {
			<- time.After(time.Minute * time.Duration(1))
			LogSystem("%s - %s 占用空间检查" , clog.logLevel , clog.getCurrentLogFilePath())

			if over := checkFileOverSize(20*_MB_ , clog.getCurrentLogFilePath()); !over {
				continue
			}

			clog.todayFileCount ++
			err := clog.createAndUseLogFile()
			if err != nil {
				panic(err)
			}
		}
	}()
}



















package cLog

import (
	"bytes"
	"fmt"
	"path"
	"runtime"
	"time"
)

const (
	Trace = 1 << iota
	Debug
	System
	Error
)

var logLevel = map[int]string{
	Trace:"TRACE",
	Debug:"DEBUG",
	System:"SYSTEM",
	Error:"ERROR",
}

func getGPID() string {
	b := make([]byte, 64)
	b = b[:runtime.Stack(b, false)]
	b = bytes.TrimPrefix(b, []byte("goroutine "))
	b = b[:bytes.IndexByte(b, ' ')]
	return string(b)
}

func getCallerInfo(level int) (string , int , bool) {
	_ , file , line , ok := runtime.Caller(level)
	if !ok {
		return "" , -1 , ok
	}
	_ , fileName := path.Split(file)
	return fileName , line , true
}

func baseLog(model string , format string , infos...interface{}) string {
	logInfo := fmt.Sprintf("[%s]" , time.Now().Format("2006-01-02 15:04:05.999"))
	if function , line , ok := getCallerInfo(3); ok {
		logInfo = fmt.Sprintf("%s|[%s:%d]" , logInfo , function , line)
	}
	logInfo = fmt.Sprintf("%s|[%s]|[%s]|" , logInfo , getGPID() , model)
	infosLog := fmt.Sprintf(format , infos...)
	logInfo = fmt.Sprintf("%s%s" , logInfo , infosLog)
	return logInfo
}

func LogTrace(format string, infos...interface{}) {
	baseLog(logLevel[Trace] , format , infos...)
}

func LogDebug(format string, infos...interface{}) {
	debugLog.msgChan <- baseLog(logLevel[Debug] , format , infos...)
}

func LogSystem(format string, infos...interface{}) {
	systemLog.msgChan <- baseLog(logLevel[System] , format , infos...)
}

func LogError(format string, infos...interface{}) {
	baseLog(logLevel[Error] , format , infos...)
}
